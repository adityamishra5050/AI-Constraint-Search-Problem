# -*- coding: utf-8 -*-
"""AI assignment Question 2(i).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AMvp37Pc-9YWgWJ8ZtPRSDKUDhnRI0YG
"""

from collections import defaultdict

def is_chef_gigglesnort(slot, chef, recipes, n):
    # Check adjacency constraints and specific rules for each chef
    if (chef == "ChefA" and (recipes.get(slot - 1) == "ChefB" or recipes.get(slot + 1) == "ChefB" or
                          recipes.get(slot - 1) == "ChefC" or recipes.get(slot + 1) == "ChefC")) or \
            (chef == "ChefC" and (slot < 5 or recipes.get(n) == "ChefC" or recipes.get(slot + 1) == "ChefN")) or \
            (chef == "ChefF" and recipes.get("Chef" + str(n-1)) and slot >= recipes["Chef" + str(n-1)]) or \
            (chef == "ChefN" and slot == n) or \
            (slot in recipes and recipes[slot] != chef):
        return False
    return True

# Function to select an unassigned dish using MRV
def select_unassigned_dish_mrv(remaining_dishes, recipes):
    mrv = float('inf')
    selected_slot = None
    for slot in remaining_dishes:
        if len(remaining_dishes[slot]) < mrv and slot not in recipes:
            mrv = len(remaining_dishes[slot])
            selected_slot = slot
    return selected_slot

# Function to select an unassigned dish
def select_unassigned_dish(remaining_dishes, recipes):
    for slot in sorted(remaining_dishes.keys()):
        if slot not in recipes:
            return slot
    return None

def cook_checking(slot, chef, remaining_dishes, recipes):
    new_remaining_dishes = remaining_dishes.copy()
    for other_slot in remaining_dishes:
        if other_slot != slot:
            new_remaining_dishes[other_slot] = [c for c in new_remaining_dishes[other_slot] if c != chef]
    return new_remaining_dishes

# Function to enforce pot consistency
def pot_consistency(remaining_dishes, slot, chef):
    queue = [(slot, chef)]
    while queue:
        current_slot, current_chef = queue.pop(0)
        for other_slot in remaining_dishes:
            if other_slot != current_slot and current_chef in remaining_dishes[other_slot]:
                remaining_dishes[other_slot].remove(current_chef)
                if len(remaining_dishes[other_slot]) == 0:
                    return False
                if len(remaining_dishes[other_slot]) == 1:
                    queue.append((other_slot, remaining_dishes[other_slot][0]))
    return True

def are_adjacent_chefs(chef1, chef2):
    forbidden_adjacent_pairs = [("C1", "C2"), ("C1", "C3"), ("C3", "Cn"), ("C3", "C5")]
    return (chef1, chef2) in forbidden_adjacent_pairs or (chef2, chef1) in forbidden_adjacent_pairs

def is_valid_dish_assignment(slot, chef, recipes, num_slots):
    if recipes.get(slot) and recipes[slot] != chef:
        return False

    # Check the adjacency constraints
    adjacent_slot_left = slot - 1
    adjacent_slot_right = slot + 1

    if recipes.get(adjacent_slot_left) and are_adjacent_chefs(recipes[adjacent_slot_left], chef):
        return False

    if recipes.get(adjacent_slot_right) and are_adjacent_chefs(recipes[adjacent_slot_right], chef):
        return False

    if chef == "C3" and slot < 5:
        return False

    if chef == "C6" and recipes.get("C" + str(num_slots - 1)) and slot >= recipes["C" + str(num_slots - 1)]:
        return False

    if chef == "C" + str(num_slots) and slot == num_slots:
        return False

    return True

# Define other functions (select_unassigned_dish_mrv, select_unassigned_dish, cook_checking, pot_consistency)

def feast_search(remaining_dishes, recipes, num_slots, order, with_pot_consistency=False):
    if len(recipes) == num_slots:
        print("Success upto Slot S8 then failure due to the constraint C1, we are not able to allot C9")
        print("Final Recipes:")
        for slot, chef in recipes.items():
            print(f"Slot {slot}: Chef {chef}")
        return True

    if with_pot_consistency:
        slot = select_unassigned_dish_mrv(remaining_dishes, recipes)
    else:
        slot = select_unassigned_dish(remaining_dishes, recipes)

    if slot is None:
        return False

    for chef in remaining_dishes[slot]:
        if is_valid_dish_assignment(slot, chef, recipes, num_slots):
            new_recipes = recipes.copy()
            new_recipes[slot] = chef
            order.append(chef)

            print(f"\nTrying to allot Slot {slot} to professor {chef}...")

            new_remaining_dishes = cook_checking(slot, chef, remaining_dishes, recipes)

            if with_pot_consistency:
                pot_consistency(new_remaining_dishes, slot, chef)

            result = feast_search(new_remaining_dishes, new_recipes, num_slots, order, with_pot_consistency)
            if result:
                return True
            else:
                order.pop()
    return False

# Define constraints-checking functions

if __name__ == "__main__":
    num_slots = 9
    slots = [i for i in range(1, num_slots + 1)]
    chefs = [f"C{i}" for i in range(1, num_slots + 1)]

    remaining_dishes = {slot: chefs[:] for slot in slots}
    remaining_dishes[1] = ["C1"]  # Constraint for slot S1 and C1

    recipes = {"S1": "C1"}  # Slot S1 allotted to C1 by default
    order = ["C1"]  # Order of allotment attempts

    print("Using only Cook Checking:")
    success_fc = feast_search(remaining_dishes, recipes, num_slots, order, with_pot_consistency=False)
    if not success_fc:
        print("Current Recipes:")
        for slot, chef in recipes.items():
            print(f"Slot {slot}: Professor {chef}")
    print("Failure due to the constraint C1, we are not able to allot C9")